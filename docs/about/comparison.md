# Comparing textX to other tools

There are generally two classes of textual DSL tools textX could be compared to.

The first class comprises tools that use classical parsing technologies, i.e.
given a grammar (usually a [context-free
grammar](https://en.wikipedia.org/wiki/Context-free_grammar)) they produce
program code capable of recognizing whether a given textual input conforms to
the given grammar. Furthermore, they enable either transformation of textual
input to a tree structure (i.e. parse tree), that is processed afterwards, or
definition of actions that should be executed during parsing if a particular
pattern is recognized. Most popular representatives in this class are [lex and
yacc](http://dinosaur.compilertools.net/), [ANTLR](http://www.antlr.org/), [GNU
bison](https://www.gnu.org/software/bison/), These kind of tools are generally
known by the name [Parser Generators](https://en.wikipedia.org/wiki/Compiler-compiler).

textX's difference in regard to this first class are following:

- textX works as grammar interpreter i.e. parser code is not generated by the
  tool but the tools is configured by the grammar to recognize textual input on
  the language specified by the grammar. You can even embed your grammar as a
  Python string. This enables faster round-trip from grammar to the working
  parsers as the parser don't need to be regenerated but only reconfigured.
- Most of the classical parsing tools use context-free grammars while textX
  uses [PEG
  grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar). The
  consequences are that lookahead is unlimited and there are no ambiguities
  possible as the [alternative operator is ordered](../grammar#ordered-choice).
  Additionally, there is no need for a separate lexer.
- textX uses a single textual specification (grammar) to define not only the
  syntax of the language but also its meta-model (a.k.a. abstract syntax). The
  textX's meta-language is inspired by Xtext. This is very important feature
  which enables automatic construction of the model (a.k.a. abstract semantic
  graph) without further work from the language designer. In classic parsing
  tools transformation to the model usually involves coding of parse actions or
  manually written parse tree transformation.


The second class of textual DSL tools are more powerful tools geared especially
towards DSL construction. These kind of tools are generally known by the name
[**Language Workbenches** coined by Martin
Fowler](http://martinfowler.com/articles/languageWorkbench.html). Most popular
representatives of this class are [Xtext](http://www.eclipse.org/Xtext/),
[Spoofax](http://www.metaborg.org/en/latest/) and
[MPS](https://www.jetbrains.com/mps/). These tools are much more complex,
highly integrated to the particular development environment (IDE) but provide
powerful tooling infrastructure for language development, debugging and
evolving. These tools will build not only parser but also a language-specific
editor and debugger.

textX is positioned between these two classes of DSL tools. The goal of textX
project is not a highly sophisticated DSL engineering platform but a simple DSL
Python library that can be used in various Python applications and development
environment. It can also be used for non-Python development using code
generation from textX models (see [Entity tutorial](../tutorials/entity)).
Tooling infrastructure, editor support etc. will be developed as independent
projects (see for example
[textx-tools](https://github.com/igordejanovic/textx-tools)).


# Difference to Xtext grammar language

textX grammar language is inspired by Xtext and thus there are a lot of
similarities between these tools when it come to grammar specification. But,
there are also differences in several places. In this section we shall outline
those differences to give users already familiar with Xtext a brief overview.

## Lexer and terminal rules

textX uses PEG parsing which doesn't needs separate lexing phase.  This
eliminate the need to define lexemes in the grammar.  Therefore, there is no
`terminal` keyword in the textX nor any of special terminal definition rules
used by Xtext.

## Types used for rules

Xtext integrates tightly with Java and Ecore typing system providing keyword
`returns` in rule definition by which language designer might define a class
used to instantiate objects recognized by the parser.

In textX there is no keyword `returns`. The class used for the rule will be
dynamically created Python class for all non-match rules. Language designer
can provide class using [user classes]() registration on meta-model.
If the rule is of [match type] than it will always return Python string or some
of base Python types for [BASETYPES inherited rules]().

## Assignment

In textX there are two types of `many` assignments (`*=` - zero or more, `+=` -
one or more) whereas in Xtext there is only one (`+=`) which defines the type
of the attribute but doesn't specify any information for the parser.  Thus, if
there should be zero or more matched elements you must additionally wrap your
expression in `zero or more` match:

In Xtext:
    

In textX:


Similarly, optional assignment in Xtext is written as:


    static?='static'?

In textX a '?' at the end of the expression is implied, i.e. rhs of the
assignment will be optional:

    static?='static'


## Repetition modifiers

textX provides a syntactic construct called [repetition modifier]() which
enables parser to be altered to a specific repetition operator instance.

For example, there is often a need to define a separated list of elements.

To match a list of integers separated by comma in Xtext you would write:

    list_of_ints+=INT (',' list_of_ints+=INT)*

In textX the same expression can be written as:

    list_of_inst+=INT[',']

The parser is instructed to parse one or more INT and comma in between.
Repetition modifier can be a regular expression match too.

For example, to match one or more integer separated by comma or semi-colon:

    list_of_ints+=INT[/,|;/]

Inside square brackets more than one repetition modifier can be defined.
See [section in the docs]() for additional explanations.

We are not aware of the similar feature in Xtext.


## Rule modifiers

Similarly to repetition modifiers, in textX parser can be altered at the rule
level too. Currently, only white-space alteration can be defined on the rule
level:

For example:
    
        Rule:
            'entity' name=ID /\s*/ call=Rule2;
        Rule2[noskipws]:
            'first' 'second';

Parser will be altered for `Rule2` not to skip white-spaces. All down the call
chain inherit modifiers.

There are hidden rules in Xtext which can achieve the similar effect, even
define different kind of tokens that can be hidden from the semantic model, but
the rule modifier in textX serve different purpose. It is a general mechanism
for parser alteration per rule that can be used in the future to define some
other alteration (e.g. case sensitivity).

## Unordered groups

Xtext support unordered groups using `&` operator.

For example:

    Modifier: 
        static?='static'? & final?='final'? & visibility=Visibility;
     
    enum Visibility:
        PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';

textX at the moment doesn't provide unordered groups. To achieve similar
feature, ordered choice in combination with `one or more` repetition operator
must be used.

    
    Modifier: 
        (static?='static' | final?='final' | visibility=Visibility)*;
     
    Visibility:
        'public' | 'private' | 'protected';


But, on the grammar level it doesn't prevent user to repeat one of the
alternatives many times.

## Syntactic predicates

textX is backtracking parser, thus unlimited lookahead is always used.
However, there still are situations where ambiguities arise. These ambiguities
are always at the point of decision which of the alternative parsing expression
to chose.  In the case of LL(\*) parser used by Xtext the order will be
implementation specific and thus can lead to ambiguities on many occasions.  In
the case of textX it will always be from left to right as defined by PEG
ordered choice operator. But, even though the order in PEG case is
predetermined, sometimes the order that should be taken depends on the input
string itself.

Consider [this example]():



In this case syntactic predicates are used to cut of additional parse trees
that would be produced if all path should be followed and produce only one.

textX syntactic predicates are defined using positive and negative lookahead.

In Xtext there is a syntactic predicate which aids in solving ambiguities 


## Hidden rules

Xtext uses hidden terminal rules to suppress non-important parts of the input
from the semantic model. This is used for comments, whitespaces etc.
Terminal rules are referenced from the `hidden` list in the parser rules. All
rules called from the one using hidden terminals inherits them.

textX provides support for whitespaces on the parser level and rule level and
a special match rule `Comment` that can be used to describe comments pattern.

## Parent-child relationships

textX will provide explicit `parent` reference on all objects that are
*contained* inside some other objects.  This attribute is a plain Python
attribute. The relationship is imposed by the grammar.

Xtext, begin based on Ecore, provides similar mechanism through Ecore API.

## Enums

Xtext support [Enum
rules](http://www.eclipse.org/Xtext/documentation/301_grammarlanguage.html#enum-rules)
while textX does not. In textX you use match rule with ordered choice to mimic
enums.


## Scoping

At present stage textX doesn't provide builtin mechanism for scoping definition.
However, this can be done in Python using object processors but there is no
specific API that could help language developer in resolving links.

Xtext does provide a [Scoping
API](http://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping)
which can be used by the Xtend code to specify scoping rules.


# Additional differences in the tool usage

## Post-processing

## Parser control

## User classes

## Builtin objects

## IDE integration

Xtext is integrated in Eclipse and InteliJ IDEs and generates full
language-specific tool-chain from the grammar description and additional
specifications.

textX does not provide IDE integrations. There is [textx-tools]() project which
provide pluggable platform for developing textX languages and generators with
project scaffolding. Integration for popular code editors is planned. There is
some basic [support for vim]() at the moment. There is a support for
visualization of grammars (meta-models) and models but the model visualization
is generic, i.e. it will show you the object graph of your model objects. We
plan to develop language-specific model visualization support.



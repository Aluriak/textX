# Comparing textX to other tools

There are generally two classes of textual DSL tools textX could be compared to.

The first class comprises tools that use classical parsing technologies, i.e.
given a grammar (usually a [context-free
grammar](https://en.wikipedia.org/wiki/Context-free_grammar)) they produce
program code capable of recognizing whether a given textual input conforms to
the given grammar. Furthermore, they enable either transformation of textual
input to a tree structure (i.e. parse tree), that is processed afterwards, or
definition of actions that should be executed during parsing if a particular
pattern is recognized. Most popular representatives in this class are [lex and
yacc](http://dinosaur.compilertools.net/), [ANTLR](http://www.antlr.org/), [GNU
bison](https://www.gnu.org/software/bison/), These kind of tools are generally
known by the name [Parser Generators](https://en.wikipedia.org/wiki/Compiler-compiler).

textX's difference in regard to this first class are following:

- textX works as grammar interpreter i.e. parser code is not generated by the
  tool but the tools is configured by the grammar to recognize textual input on
  the language specified by the grammar. You can even embed your grammar as a
  Python string. This enables faster round-trip from grammar to the working
  parsers as the parser don't need to be regenerated but only reconfigured.
- Most of the classical parsing tools use context-free grammars while textX
  uses [PEG
  grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar). The
  consequences are that lookahead is unlimited and there are no ambiguities
  possible as the [alternative operator is ordered](../grammar#ordered-choice).
  Additionally, there is no need for a separate lexer.
- textX uses a single textual specification (grammar) to define not only the
  syntax of the language but also its meta-model (a.k.a. abstract syntax). The
  textX's meta-language is inspired by Xtext. This is very important feature
  which enables automatic construction of the model (a.k.a. abstract semantic
  graph) without further work from the language designer. In classic parsing
  tools transformation to the model usually involves coding of parse actions or
  manually written parse tree transformation.


The second class of textual DSL tools are more powerful tools geared especially
towards DSL construction. These kind of tools are generally known by the name
[**Language Workbenches** coined by Martin
Fowler](http://martinfowler.com/articles/languageWorkbench.html). Most popular
representatives of this class are [Xtext](http://www.eclipse.org/Xtext/),
[Spoofax](http://www.metaborg.org/en/latest/) and
[MPS](https://www.jetbrains.com/mps/). These tools are much more complex,
highly integrated to the particular development environment (IDE) but provide
powerful tooling infrastructure for language development, debugging and
evolving. These tools will build not only parser but also a language-specific
editor and debugger.

textX is positioned between these two classes of DSL tools. The goal of textX
project is not a highly sophisticated DSL engineering platform but a simple DSL
Python library that can be used in various Python applications and development
environment. It can also be used for non-Python development using code
generation from textX models (see [Entity tutorial](../tutorials/entity)).
Tooling infrastructure, editor support etc. will be developed as independent
projects (see for example
[textx-tools](https://github.com/igordejanovic/textx-tools)).

